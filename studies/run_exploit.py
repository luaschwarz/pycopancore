"""Test Study for the exploit model.

A study to test the runner with the exploit model.
It includes the module components exploit_social_learning,
most_simple_vegetation and simple_extraction.
"""

# This file is part of pycopancore.
#
# Copyright (C) 2016-2017 by COPAN team at Potsdam Institute for Climate
# Impact Research
#
# URL: <http://www.pik-potsdam.de/copan/software>
# Contact: core@pik-potsdam.de
# License: BSD 2-clause license

import numpy as np
from time import time
import datetime as dt
from numpy import random

import plotly.offline as py
import plotly.graph_objs as go

import pycopancore.models.exploit as M
from pycopancore.runners.runner import Runner

#parameters:
timeinterval = 200
timestep = 1
ni_sust = 200  # number of agents with sustainable strategy 1
ni_nonsust = 200  # number of agents with unsustainable strategy 0
nindividuals = ni_sust + ni_nonsust
nc = nindividuals # number of cells
p = 0.05  # link density
strategies = [0, 1]
average_waiting_time = 2.5
run_set_no = "49" # give explicit number of runset
configuration = {
    "average waiting time": average_waiting_time
}

# New Order of instantiating things !!!!!
# instantiate model
model = M.Model()

# instantiate process taxa culture:
culture = M.Culture(average_waiting_time=average_waiting_time)

# generate entitites:
world = M.World(culture=culture)
social_system = M.SocialSystem(world=world)
cells = [M.Cell(stock=1, capacity=1, growth_rate=1, social_system=social_system)
         for c in range(nc)]
individuals = [M.Individual(strategy=np.random.choice(strategies),
                            imitation_tendency=1,
                            rewiring_prob=0.0,
                            cell=cells[i]) for i in range(nindividuals)]

for (i, c) in enumerate(cells):
    c.individual = individuals[i]


def erdosrenyify(graph, p=0.5):
    """Create a ErdosRenzi graph from networkx graph.

    Take a a networkx.Graph with nodes and distribute the edges following the
    erdos-renyi graph procedure.
    """
    assert not graph.edges(), "your graph has already edges"
    nodes = list(graph.nodes())
    for i, n1 in enumerate(nodes[:-1]):
        for n2 in nodes[i+1:]:
            if random.random() < p:
                graph.add_edge(n1, n2)

# set the initial graph structure to be an erdos-renyi graph
print("erdosrenyifying the graph ... ", end="", flush=True)
start = time()
erdosrenyify(culture.acquaintance_network, p=p)
print("done ({})".format(dt.timedelta(seconds=(time() - start))))

print('\n runner starting')

r = Runner(model=model)
start = time()
traj = r.run(t_1=timeinterval, dt=timestep)
runtime = dt.timedelta(seconds=(time() - start))
print('runtime: {runtime}'.format(**locals()))

t = np.array(traj['t'])
print("max. time step", (t[1:]-t[:-1]).max())
# print('keys:', np.array(traj.keys()))
# print('completeDict: ', traj)

individuals_strategies = np.array([traj[M.Individual.strategy][ind]
                                 for ind in individuals])

nopinion1_list = np.sum(individuals_strategies, axis=0) / nindividuals
nopinion0_list = 1 - nopinion1_list

########################################################################################################################

# decide if results should be saved:
mc_save = "y" # "y" or "n"


import os
import json
from pickle import dump
os_path = "C:\\Users\\bigma\\Documents\\Uni\\Master\\MA_Masterarbeit\\exploit"

import datetime
current_time = datetime.datetime.now()
current = [current_time.month, current_time.day, current_time.hour, current_time.minute, current_time.second]
time_string = f"{current_time.year}"
parent_directory_name = f"{current_time.year}"
for i in current:
    if i < 10:
        time_string += f"_0{i}"
    else:
        time_string += f"_{i}"

for i in current[:2]:
    if i < 10:
        parent_directory_name += f"_0{i}"
    else:
        parent_directory_name += f"_{i}"
# save_time = f"{current_time.year}_" + f"{current_time.month}_" + f"{current_time.day}_" \
#             + f"{current_time.hour}_" + f"{current_time.minute}_" + f"{current_time.second}"

# Directory
directory = f"Run_{time_string}"

# Path
my_path = os.path.join(os_path, parent_directory_name)

# import json
# f = open(my_path + "_traj_dic.json", "wb")
# json.dump(traj, f)

mc_path = "C:\\Users\\bigma\\Documents\\Uni\\Master\\MA_Masterarbeit\\exploit\\mc"
# Path
my_mc_path = os.path.join(mc_path, parent_directory_name)

if mc_save == "y":
    # Create the directory
    if not os.path.exists(my_mc_path):
        os.mkdir(my_mc_path)
        print(f"Directory {parent_directory_name} created @ {my_mc_path}")
    run_no = []

    for i in range(500):
        run_no.append(str(i))
    # if args.runset_no:
    #     run_set_no = args.runset_no
    # else:
    #     run_set_no = directory
    run_set_no_path = os.path.join(my_mc_path, run_set_no)
    if not os.path.exists(run_set_no_path):
        os.mkdir(run_set_no_path)
        print(f"Directory {run_set_no} created @ {run_set_no_path}")

    config_path = f"{run_set_no_path}\\configuration.json"
    if not os.path.exists(config_path):
        print("Saving configuration.json.")
        f = open(config_path, "w+")
        json.dump(configuration, f, indent=4)
        print("Done saving configuration.json.")

    # saving traj
    # create a binary pickle file
    for n in run_no:
        run_no_path = os.path.join(run_set_no_path, n)
        output_name = run_no_path + ".pickle"
        if not os.path.exists(output_name):
            f = open(output_name, "wb")
            tosave = {
                v.owning_class.__name__ + "."
                + v.codename: {str(e): traj[v][e]
                               for e in traj[v].keys()
                               }
                for v in traj.keys() if v is not "t"
            }
            del tosave["Culture.acquaintance_network"]
            tosave["t"] = traj["t"]
            t = tosave["t"]
            print("Saving output.")
            dump(tosave, f)
            print("Done saving output.")
            break

import winsound
winsound.Beep(440, 1000)