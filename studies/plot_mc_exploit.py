import numpy as np
from time import time
import datetime as dt
from numpy import random
import json
import networkx as nx
import os
import pickle
from matplotlib import pyplot as plt
import numpy as np
import plotly.graph_objs as go
import matplotlib.pyplot as plt
import plotly.offline as py
import matplotlib.colors as colors
import matplotlib.cm as cmx
import datetime
import glob

#---paths and dirs---

# data from which date?
date = "2022_10_18"
# data from which set?
runsets = ["30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49"]
Dt = [0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625, 1.75, 1.875, 2.0, 2.125, 2.25, 2.375, 2.5]
traj_paths = []
for r in runsets:
    traj_paths.append(f"C:\\Users\\bigma\\Documents\\Uni\\Master\\MA_Masterarbeit\\exploit\\mc\\{date}\\{r}\\")

print(traj_paths)
Ns = []
# run counter
for p in traj_paths:
    Ns.append(len(glob.glob1(p,"*.pickle")))
# N = 5 # run numbers
N = 0
for n in Ns:
    N += n

#---load data---
Traj = []
for count, p in enumerate(traj_paths):
    traj = []
    for i in range(Ns[count]):
        print(f"Loading {i}.pickle from {p}...")
        traj.append(pickle.load(open(p+str(i)+".pickle","rb")))
    Traj.append(traj)

T, Cells, Individuals = ([] for i in range(3))
for i in Traj:
    t, cells, individuals = ([] for i in range(3))
    for k in i:
        t.append(np.array(k["t"]))
        cells.append(list(k["Cell.stock"].keys()))
        individuals.append(list(k["Individual.strategy"].keys()))
    T.append(t)
    Cells.append(cells)
    Individuals.append(individuals)

nindividuals = 400
timeinterval = 200
timestep = 1

print("Done loading things!")
########################################################################################################################

Total_stock, Nbehav1 = ([] for i in range(2))
for count1, i in enumerate(Traj):
    individuals_behaviours, total_stock, nbehav1 = ([] for i in range(3))
    for count2, k in enumerate(i):
        individuals_behaviours.append(np.array([k["Individual.strategy"][ind]
                                       for ind in Individuals[count1][count2]]))
        stock = k["Cell.stock"]
        total_stock.append(np.divide(np.sum([stock[c] for c in Cells[count1][count2]], axis=0), nindividuals))
        nbehav1.append(np.divide(np.sum(individuals_behaviours[count2], axis=0), nindividuals))
    Total_stock.append(total_stock)
    Nbehav1.append(nbehav1)

values = range(len(Ns))
jet = cm = plt.get_cmap('jet')
cNorm  = colors.Normalize(vmin=0, vmax=values[-1])
scalarMap = cmx.ScalarMappable(norm=cNorm, cmap=jet)

###plot

# fig = plt.figure()
# for count1, n in enumerate(Ns):
#     colorVal = scalarMap.to_rgba(values[count1])
#     for count2 in range(n):
#         plt.plot(T[count1][count2], Nbehav1[count1][count2], color=colorVal,)# label=f"run {count}")
# # plt.legend()
# plt.title("")
# plt.xlabel("$t$")
# plt.ylabel("$n_s$")
# plt.show()
# plt.close(fig)
#
# fig = plt.figure()
# for count1, n in enumerate(Ns):
#     colorVal = scalarMap.to_rgba(values[count1])
#     for count2 in range(n):
#         plt.plot(T[count1][count2], Total_stock[count1][count2], color=colorVal)# , label=f"run {count}")
# # plt.legend()
# plt.title("")
# plt.xlabel("$t$")
# plt.ylabel("$s$")
# plt.show()
# plt.close(fig)


def correct_timeline(lists, t_lists, shape, t_new):
    """Correct the timeline of one list to have same time points.
    Careful, depending on the resolution of t_new some data might be lost!
    lists: list or list of list containing data
    t_lists: list or list of list containing time points and are of different length
    shape: "1d" if single list, "2d" if list of lists
    t_new: time shape lists should be cast into
    """
    print(f"Correcting time line of lists...")

    if shape == "2d":
        new_list = []
        n_lists = len(lists)
        for i in range(n_lists):
            new_sub_list = []
            for index, t in enumerate(t_new[1:]):
                list_index = 0
                for count, k in enumerate(t_lists[i]):
                    if k >= t_new[index - 1] and k < t_new[index]:
                        list_index = count
                new_sub_list.append(lists[i][list_index])
            new_sub_list.append(lists[i][len(lists[i])-1])
            new_list.append(new_sub_list)

    else: # 1d
        new_list = []
        list_index = 0
        for index, t in enumerate(t_new[1:]):
            for count, k in enumerate(t_lists):
                if k >= t_new[index-1] and k < t_new[index]:
                    list_index = count
            new_list.append(lists[list_index])
        new_list.append(lists[len(lists)-1])

    print(f"Done correcting timelines!")
    return new_list

Mean_nbehav1, Std_nbehav1, Mean_total_stock, Std_total_stock = ([] for i in range(4))
t_mean = np.arange(0, timeinterval, timestep)
for count, i in enumerate(Traj):
    corrected_nbehav1 = correct_timeline(Nbehav1[count], T[count], "2d", t_mean)
    mean_nbehav1 = np.mean(corrected_nbehav1, axis=0)
    std_nbehav1 = np.std(corrected_nbehav1, axis=0)
    Mean_nbehav1.append(mean_nbehav1)
    Std_nbehav1.append(std_nbehav1)
    corrected_total_stock = correct_timeline(Total_stock[count], T[count], "2d", t_mean)
    Mean_total_stock.append(np.mean(corrected_total_stock, axis=0))
    Std_total_stock.append(np.std(corrected_total_stock, axis=0))

fig = plt.figure()
for count in range(len(Ns)):
    colorVal = scalarMap.to_rgba(values[count])
    plt.plot(t_mean, Mean_total_stock[count], color=colorVal)
    # plt.fill_between(t_mean, Mean_total_stock[count]-Std_total_stock[count], Mean_total_stock[count]+Std_total_stock[count],
    #                      facecolor=colorVal, edgecolor=colorVal, alpha=0.1)
plt.xlabel("$t$")
plt.ylabel(r"$ \langle s \rangle$")
plt.show()
plt.close(fig)

fig = plt.figure()
for count in range(len(Ns)):
    colorVal = scalarMap.to_rgba(values[count])
    plt.plot(t_mean, Mean_nbehav1[count], color=colorVal)
    # plt.fill_between(t_mean, Mean_nbehav1[count]-Std_nbehav1[count], Mean_nbehav1[count]+Std_nbehav1[count],
    #                      facecolor=colorVal, edgecolor=colorVal, alpha=0.1)
plt.xlabel("$t$")
plt.ylabel(r"$ \langle n_s \rangle$")
plt.show()
plt.close(fig)

# plot runs plus mean
# fig = plt.figure()
# for count1, n in enumerate(Ns):
#     colorVal = scalarMap.to_rgba(values[count1])
#     for count2 in range(n):
#         plt.plot(T[count1][count2], Nbehav1[count1][count2], color=colorVal,)
# for count in range(len(Ns)):
#     plt.plot(t_mean, Mean_nbehav1[count], color="black", label=r"$\langle s \rangle$")
#     plt.fill_between(t_mean, Mean_nbehav1[count]-Std_nbehav1[count], Mean_nbehav1[count]+Std_nbehav1[count],
#                           facecolor="black", edgecolor="black", alpha=0.1)
# plt.xlabel("$t$")
# plt.ylabel(r"$n$")
# plt.show()
# plt.close(fig)
#
# fig = plt.figure()
# for count1, n in enumerate(Ns):
#     colorVal = scalarMap.to_rgba(values[count1])
#     for count2 in range(n):
#         plt.plot(T[count1][count2], Total_stock[count1][count2], color=colorVal,)
# for count in range(len(Ns)):
#     plt.plot(t_mean, Mean_total_stock[count], color="black", label=r"$\langle s \rangle$")
#     plt.fill_between(t_mean, Mean_total_stock[count]-Std_total_stock[count], Mean_total_stock[count]+Std_total_stock[count],
#                           facecolor="black", edgecolor="black", alpha=0.1)
# plt.xlabel("$t$")
# plt.ylabel(r"$s$")
# plt.show()
# plt.close(fig)


# plot against DeltaT
fig = plt.figure()
for n in range(len(Ns)):
    plt.scatter(Dt[n], Mean_nbehav1[n][len(t_mean)-1], color="navy")
    plt.errorbar(Dt[n], Mean_nbehav1[n][len(t_mean)-1], yerr=Std_nbehav1[n][len(t_mean)-1], color="navy")
plt.xlabel(r"$\Delta T$")
plt.ylabel(r"$ \langle n_s \rangle$")
plt.show()
plt.close(fig)

fig = plt.figure()
for n in range(len(Ns)):
    plt.scatter(Dt[n], Mean_total_stock[n][len(t_mean)-1], color="navy")
    plt.errorbar(Dt[n], Mean_total_stock[n][len(t_mean)-1], yerr=Std_total_stock[n][len(t_mean)-1], color="navy")
plt.xlabel(r"$\Delta T$")
plt.ylabel(r"$ \langle s \rangle$")
plt.show()
plt.close(fig)

from pickle import dump
f = open("Mean_total_stock.pickle", "wb")
dump(Mean_total_stock, f)
f = open("Mean_nbehav1.pickle", "wb")
dump(Mean_nbehav1, f)
f = open("Std_total_stock.pickle", "wb")
dump(Std_total_stock, f)
f = open("Std_nbehav1.pickle", "wb")
dump(Std_nbehav1, f)